### redux 
* 唯一数据源：即应用的状态数据应该只存在唯一一个 Store 上。
> 整个应用只保持一个 Store,好处就是我们可以随时提出整个应用的状态进行持久化，即时保存功能。存在一个问题就是，数据源会很大，combineReducer来解决
* 保持状态只读。
* 数据改变只能通过纯函数完成。
#### reducer
- 响应action,修改store的纯函数
- 根据previousState、action返回newState，假如是第一次的话还有进行state的初始化
#### 工作原理
- createStore说起
- Reducer
- 和react的连接
- connect高阶组件
### fibre
fiber是一个对象，是要给链表树
产生的原因：当渲染的组件很大的时候，reconciliation占有JS主进程很长时间，导致页面响应较差，动画、手势效果不好。
fiber:期望是能够高优先级的任务能够打断低优先级的任务，设想没次都执行一小段的任务，执行完之后看看任务队列有没有优先级较高的让它限制性
fiber：是一个链表树，它上面有stateNode节点管理自身状态的、child和subling节点指向的是下一个工作单元，return表示处理完后要返回的结果要合并的目标，一般指向父节点
### 错误边界
可以捕获出错的组件，而不是UnMount整个组件
之前，一旦某个组件发生错误，整个组件树将会从根节点被unmount下来。React 16修复了这一点，引入了Error Boundary的概念，中文译为“错误边界”，当某个组件发生错误时，我们可以通过Error Boundary捕获到错误并对错误做优雅处理，如使用Error Boundary提供的内容替代错误组件。Error Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）
### render方法返回值
在React 16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。
### setState传入null
setState传入null时不会触发更新
### 生命周期
#### getDerivedStateFromProps
这两者最大的不同就是:
在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。
在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。
而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。
#### getSnapshotBeforeUpdate(prevProps, prevState)
代替componentWillUpdate。
常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。
这两者的区别在于：在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在
componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。
getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。
此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。
### Portal
- 使用createPortal将组件渲染到当前组件树之外。这个新特性可以很好的用来做弹窗啊，蒙层啊。默认情况下，要实现这些组件，要把他们放在顶层，但是实际上这个组件应该时属于某个组件的，可以受到某个组件的控制。portal就提供这样的一种实现方式，dom结构不是你的父节点，但是逻辑上和事件捕获上确实你的父节点。
