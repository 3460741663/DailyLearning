## DNS
- 把域名解析成为IP地址，流程如下
1. 我先询问本地DNS缓存(本地的运营商)，看看它的缓存里有没有这样一条的记录，域名和ip的记录，如果由就返回回来就完了
2. 没有的话，就去找本地DNS服务器
3. 本地DNS服务器就去找根域名服务器，根域名服务器不直接用于域名解析，但是它能只给你一条路
> 比如说，你是要www.163.com，根域名服务器发现你是.com，他就会告诉.com的顶级域名服务器的地址给你
4. 本地DNS服务器就去找顶级域名服务器，它就帮你找到这个域名的权威域名服务器的地址
5. 本地DNS就去权威域名服务器帮你找，然后得到一个IP地址
6. 本地DNS就把这个IP地址给你，然后你去访问这个IP地址
### 全局负载均衡
- 指的就是DNS负载均衡，一个域名解析对应很多的IP地址，解析的时候，返回给你一个压力最小的服务器的IP给你
### CDN 
- 内容分发网络，就是上述DNS负载均衡的一个实现，利用最靠近每位用户的服务器，更快、更好、更可靠的将音乐、视频图片、应用程序及其他文件发送给用户，来提高性能。
- 分成中心节点、区域节点、边缘节点，区别就是存储的数据量的不同，先从边缘节点找起，然后区域节点、中心节点，这个过程叫做回源
- 源站就是网站的真实服务器，从源站取内容叫做回源
## HTTP
- HTTP1.1是一个纯文本传输
- HTTP是基于TCP协议的，要先建立TCP连接，目前大部分的HTTP协议大部分都是1.1，默认开启`Connection:Keep-Alice`
> 意思就是网络连接是持久的，这样建立的TCP连接可以在多次请求中复用

## HTTP2.0的优点
- 头部压缩，HTTP1.1每次通信都要带完整的HTTP头，非常的冗余。HTTP2.0就对HTTP头进行了一定的压缩，将每次要携带的key,value在两端建立索引表，对于已经由的头，只要发送索引就好了，让它到达之后自己取匹配头
- 服务端推送、流的形式传输 HTTP2.0将一个TCP的连接切分成多个流，每个流都有自己的ID,流可以从客户端发往服务端也可以服务端发往客户端，而且流是有优先级的
- 分帧、二进制编码 HTTP2.0还将所有的传输信息分割为更小的帧和信息，并对他们进行二进制编码，比如说header帧单独开启流、data帧同属一个流
- http2.0可以将多个请求分散到不同的流中，将请求内容拆分成帧进行二进制传输，然后根据帧首部重新组装，也可以根据优先级决定先处理那一个流
> 比如说我们一个页面要请求js、css、jpg，如果是http1.1，这些请求就是穿行的，一个一个请求，而HTTP2.0就可以同时发送多个请求，然后接受多次的回应，不用一一对应
### HTTP 队首阻塞
- 队首阻塞：服务端必须按照请求发送的顺序返回响应，如果一个响应延迟了，那么后续的请求就都会延迟。根据上面的原理，同时将页面的多个请求同时发往服务端，能够加快页面组件的传输速度
- 但是没有解决TCP的队首阻塞，TCP协议在处理包的时候是很严格的，按序到达，当一个数据包处理问题，TCP要等这个包重传完才能继续
- 使用QUIC协议来解决，谷歌对UPD协议的一个改进

