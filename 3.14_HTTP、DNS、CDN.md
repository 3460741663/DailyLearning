## DNS
- 把域名解析成为IP地址，流程如下
1. 我先询问本地DNS缓存(本地的运营商)，看看它的缓存里有没有这样一条的记录，域名和ip的记录，如果由就返回回来就完了
2. 没有的话，就去找本地DNS服务器
3. 本地DNS服务器就去找根域名服务器，根域名服务器不直接用于域名解析，但是它能只给你一条路
> 比如说，你是要www.163.com，根域名服务器发现你是.com，他就会告诉.com的顶级域名服务器的地址给你
4. 本地DNS服务器就去找顶级域名服务器，它就帮你找到这个域名的权威域名服务器的地址
5. 本地DNS就去权威域名服务器帮你找，然后得到一个IP地址
6. 本地DNS就把这个IP地址给你，然后你去访问这个IP地址
### 全局负载均衡
- 指的就是DNS负载均衡，一个域名解析对应很多的IP地址，解析的时候，返回给你一个压力最小的服务器的IP给你
### CDN 
- 内容分发网络，就是上述DNS负载均衡的一个实现，利用最靠近每位用户的服务器，更快、更好、更可靠的将音乐、视频图片、应用程序及其他文件发送给用户，来提高性能。
- 分成中心节点、区域节点、边缘节点，区别就是存储的数据量的不同，先从边缘节点找起，然后区域节点、中心节点，这个过程叫做回源
- 源站就是网站的真实服务器，从源站取内容叫做回源
## HTTP
- HTTP1.1是一个纯文本传输
- HTTP是基于TCP协议的，要先建立TCP连接，目前大部分的HTTP协议大部分都是1.1，默认开启`Connection:Keep-Alice`
> 意思就是网络连接是持久的，这样建立的TCP连接可以在多次请求中复用
## HTTP2.0 深入剖析
### 头部压缩
- 头部压缩，HTTP1.1每次通信都要带完整的HTTP头，非常的冗余。HTTP2.0就对HTTP头进行了一定的压缩，将每次要携带的key,value在两端建立索引表，对于已经有的字段，只要发送索引就好了，让它到达之后自己取匹配头
- 把请求行干掉了，然后把请求行里的字段放到请求头里，起名字叫做伪头字段，用':'区分
### 二进制编码
- HTTP1.0是明文传输，优点就是调试很方便
- HTTP2.0为了想TCP协议靠拢，全面采用二进制编码
### 分帧
1. 帧结构如图帧长度、实际传输数据
2. 帧分为数据帧和控制帧，比如说HEADER帧和DATA帧就是数据帧，PRIORITY就是控制帧，帧的优先级就是靠这个帧类型来标识的
3. 流标识符就用来模拟流的，用来区分不同的流，也就是不同的请求和应道通道
### 流
1. 流是一个虚拟的概念，帧才是真实存在的，流这个概念是靠帧上面的标识符来体现的，时间上帧的传递时乱序的，双向的，而流的优先级是靠帧类型来体现的
2. 一个流就是一个请求和应答
3. 流是可以双向流动的，可并发的的，所以http2.0支持服务端推送，和多路复用
### 服务端推送
- HTTP/2.0在一定程度上改变了传统的'请求-应答'工作模式，服务器不在被动的响应请求，也可以新建'流'主动给客户端发消息
- 比如在浏览器刚请求HTML的时候，就提前把可能会用到的JS、CSS文件发送个客户端，减少延迟
### 多路复用
- 流是可以并发的，这个实现了多路复用
> 比如说我们一个页面要请求js、css、jpg，如果是http1.1，这些请求就是串行执行，一个一个请求，而HTTP2.0就可以同时发送多个请求，然后接受多次的回应，不用一一对应，这个就解决了HTTP的对首阻塞问题
### HTTP 队首阻塞
- 队首阻塞：服务端必须按照请求发送的顺序返回响应，如果一个响应延迟了，那么后续的请求就都会延迟。根据上面的原理，同时将页面的多个请求同时发往服务端，能够加快页面组件的传输速度
- 但是没有解决TCP的队首阻塞，TCP协议在处理包的时候是很严格的，无差错、不丢失、不重复、按序到达，当一个数据包出了，TCP要等这个包重传完才能继续
- 使用QUIC协议来解决，谷歌对UPD协议的一个改进



