## diff算法
### React diff的三个策略
* DOM节点夸层级移动的很少，几乎可以忽略
* 拥有相同类的组件会生成相似的树形结构，不同类型的的组件俩个组件会生成不同的树形结构
* 对于同一层级的一组节点，我们允许使用唯一的key来区分
### React diff的三个阶段
#### tree diff
- 基于策略一，React对树的diff只会进行分层比较，两棵树只会对同一层次的节点进行比较
- 当发现父节点不在时，它的所有子节点也会被删除
- 如果是跨层级移动操作，就会把原来位置的节点删掉，再新的位置创建出一个新的树，所以官方建议不要进行跨层级操作
### component diff
- 基于策略二，如果是同一个类型的组件，那么就按照原策略继续比较Virtual Dom
- 如果是不同类型的组件，讲该组件判为dirty组件，替换整个组件的所有子节点
- 对于同义类型的组件，它的虚拟树可能没有变，所以react向开发者提供一个shouldCompountUpdate来明确这个组件是否更新，默认是true
### element diff
- 当节点处于同一层级的时候，diff提供了三种操作:插入、移动、删除
- 当新的组件类型不在旧的集合里就要插入操作
- 旧组件的类型再新集合里也有，但是element不同；或者旧的类型在新的集合里没有，就要进行删除操作
- 旧组件在新集合了，且是复用的就要进行移动操作了
- 移动操作的更新原则就是把左边的往右边移动，单边操作减少时间复杂度
- 基于上诉算法，官方建议不要把最后一个节点挪到最前面来
## patch 补丁
就是把diff出来的差异，更新到浏览器显示，让浏览器显示最新的内容。很简单的操作，就是让它读取差异队列，因为这个差异队列就是对树的遍历，它是逐上而下的有序的，所以可以直接读，然后更新