## TCP 和 UDP 有哪些区别
### TCP 是面向连接的：
- TCP 提供可靠交付，TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达
- TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。
- TCP 流量控制，依据对方的接受情况，处理能力，A --> B, B接收到之后是要给 A 一个回执，
- TCP 是面向字节流的。发送的时候发的是一个流，没头没尾。

### UDP 是面向无连接的：
- UDP 继承了 IP 包的特性（IP 包是没有任何可靠性保证的，一旦发出去，就像西天取经，走丢了、被妖怪吃了，都只能随它去），不保证不丢失，不保证按顺序到达
- UDP 就不会拥塞控制，应用让我发，我就发，管它洪水滔天。
- UDP 继承了 IP 的特性（IP 包可不是一个流，而是一个个的 IP 包），基于数据报的，一个一个地发，一个一个地收。
- UDP 则是无状态服务。通俗地说是没脑子的，天真无邪的，发出去就发出去了。

### UDP 包头
有源端口号和目标端口号，
再没有其他的了。和下面要讲的 TCP 头比起来，这个简直简单得一塌糊涂啊！

### 三次握手和四次挥手
#### 三次握手
- 确认双方的发送能力和接收能力
>从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态。服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。
- 凡是需要对端确认的，一定消耗TCP报文的序列号。
#### 为啥不是俩次
- 无法确认客户端的接收能力
> 客户端发了一个SNY,滞留在网络中，客户端重传一个SNY，建立好链接传输完数据后断开连接，这时候第一个SNY到了，服务端又和他简历连接，带来了连接资源的浪费
#### 为啥不是四次
- 可以四次，三次已经能达到需求了，四次浪费资源
#### 三次握手中可以携带数据嘛？
- 前俩次不行，前两次如果传输大量数据的话，服务端就要花费大量的时间和内存去处理这些数据，增加了安全隐患
- 第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。
#### 四次挥手
> 双方都处于ESTABLISHED状态，客户端发送一个FIN,自己进入FIN-WAIT-1状态，这时候的客户端进入了半关闭状态，即不能发送数据只能接受从服务端发来的报文。服务端接收到FIN并返回一个ACK,自己进入FIN-WAIT阶段，客户端接收到ACK,进入FIN-WAIT-2阶段，服务端处理完后续事务再发送一个FIN,服务端进入LAST-ACK，客户端接收到FIN,进入TIME-WAIT，发送一个ACK给服务端，服务端closed，2msl之后客户端closed
#### 为啥不是三次挥手呢？
- 等服务端的后续任务结束后，一起发ACK和FIN。这时候如果后续任务很多，会让客户端以为丢包了，会重传一个FIN。
#### 2MSL的意义
- 如果不等待：服务端发给客户端数据再路上，这时候客户端的端口被别的应用占据了，就这个应用接受到无用的数据包，发送混乱
- 预防最后一个ACK丢失，这时候以为自己的FIN对方没有收到，就重传一个FIN,但是这时已经没有客户端了
>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端;另1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达
### 半连接队列和SNY FLOOD的关系
#### 半连接队列、全连接队列
- 只接受到SNY,则进入半连接队列
- 三次握手则进入全连接队列
#### SNY FLOOD
- 就是伪造好多的IP地址，发送SNY,1. 占满半连接队列，2. 服务端接收不到ACK,服务端一直重传，耗尽资源而亡
#### SNY FLOOD解决办法
1. 扩大SNY队列的容量
2. 减少SNY + ACK重传的次数
3. SNY cookie技术，SNY不分配连接资源而是计算一个cookie给他，需要ACK的时候携带过来，验证身份才予以分配连接
### 标记位
标记位
常见的标记位有SYN,ACK,FIN,RST,PSH。
SYN 和 ACK 已经在上文说过，后三个解释如下:
FIN： 即 Finish，表示发送方准备断开连接。
PSH： 即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。
RST： RST表示复位，用来异常的关闭连接，在TCP的设计中它是不可或缺的。就像上面说的一样，发送RST包关闭连接时，不必等缓冲区的包都发出去（不像上面的FIN包），直接就丢弃缓存区的包发送RST包。而接收端收到RST包后，也不必发送ACK包来确认。
TCP处理程序会在自己认为的异常时刻发送RST包。例如，A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。
又比如，AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。

