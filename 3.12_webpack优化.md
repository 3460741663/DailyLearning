## webpack
### happyPack
- 因为node是单线的，然后webpack是基于node的，无法使用现代机器的多核处理器的优势，打包时间要很久，happyPack的作用就是开启多线程打包,提高打包速度，在模块很大的时候才有效。
- 在plugin了new这个插件，你可以指定线程池的数量根据你的cpu核数
### MinCssExtractPlugin
- 用来提取css文件的
### 生产环境的优化
#### 分离基础库
- 你在开放业务的时候可能会引入一些第三方的库比如react、react-dom啊，这些都是较为长时间不改变的，你把它分离出来，让它不打包或者少次数的打包。分离出来后，你可以单独对这些基础库延长缓存时间，提高http请求体验
##### external
- 打包的时候，把这些基础库划分开来，不然它进行打包，排除在外
- 没有打包的话，你的引用不到它啊，你可以手动引入MDN上的，或者自己的线上资源，
- 通过script请求到这些资源，然后你需要的时候，就去window上找就好了
##### spliteChunkPlugin
把基础库单独打包，把它抽出来
##### DLL动态链接库
第三方的库，你单独跑一个打包命令，它就放在那里， 你想更新的时候再打包一次，不然的话，你每次打包就只打包了你自己的业务代码，再引用的时候引入就好了。
#### TreeShaking
在模块引用时候，把没有用到的代码块干掉
原理：es6模块静态解析的能力，就是在解析阶段就可以输出模块的依赖关系。
#### 动态导入
动态导入的，把动态导入的代码单独打包，显然比打包在一块优势
#### sourceMap
- webpack打包的时候改变了源码，在调试的时候非常的不方便，因为保存的行列已经对不上了，sourceMap就解决这个问题。
- 但是sourceMap使用不当的话，会导致源码泄露。最简单的处理方法就是在开发环境开启，生产环境下关闭它。或者把它防灾内网，不暴露它在外网。
#### eval
- 把打包的内容用eval包住，然后再末尾用sourceURL执行你的源代码，这样执行时eval包裹的值的时候，如果报错，你就指定你的源码哪里报错了
#### source-map
- 会生成一个映射文件，打包后的代码和源码的一个映射文件
#### inline-source-map
- 就是把映射文件放在打包完了的代码末尾
#### cheap 
- 忽略列信息，报错的时候只包行错误
### scopeHoistring
- 打包完之后存在大量的闭包，作用域很多，内存开销大
- scopeHoistring原理就是：按照引入顺序放在一个函数作用域里，适当的重命名防止冲突
- 必须使用ES module，运用的也是静态分析
### 多入口打包
- 不优化的话，会打包重复的文件
#### 提取公共模块，使用splitChunks
- name 打包出来的文件
- chunk: all 就是不管同步异步映入的都要提取公共模块
- minChunks 最少引入次数
- minSize 0
- 不管你时同步异步引入的方式，你的引入次数超过2次就要提取出来
